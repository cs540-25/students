netid: amcdan23
ghid: adam-mcdaniel
name: Adam McDaniel

## Me
---

Hello, [I'm Adam McDaniel🧑🏻‍🦰](https://adam-mcdaniel.net). I'm a PhD computer science student under Dr. Jantz working on memory systems optimization/profiling.
I write a lot of Rust🦀.

### My Interesting Links🌐

|Website|
|---|
|[My programming language🧑‍💻](https://adam-mcdaniel.net/sage-website)|
|[My shell🐚](https://adam-mcdaniel.net/dune-website/)|
|[My blog📝](https://adam-mcdaniel.net/blog)|
|[My YouTube📽️ (compilers and music)](https://youtu.be/QdnxjYj1pS0?si=pwvegcPkEvqmqF8b)|

## My Project Interests
---

>[!NOTE]
> For the class project, I'm really interested in working on projects related to compilers/interpreters/automated theorem proving! It's really fun and rewarding to build tools like these -- it's like making your own paint from scratch.

Some ideas I have are:

### My Favorite Ideas💡

1. An implementation of [the DOT calculus](https://lampwww.epfl.ch/~amin/dot/fool.pdf), the core language that Scala is based on. It's definitely been on my list of things to try for a while.
2. A type checker and/or compiler for [Featherweight Go](https://arxiv.org/pdf/2005.11710) [Featherweight Java](https://www.cis.upenn.edu/~bcpierce/papers/fj-toplas.pdf) -- if you can compile these, it's straight forward to compile the full languages! [System F](https://en.wikipedia.org/wiki/System_F) would be a fun + easier target, but I think the non-functional features of Featherweight Go/Java would be more interesting.
3. A declarative logic language like [Datalog](https://en.wikipedia.org/wiki/Datalog) or [Prolog](https://en.wikipedia.org/wiki/Prolog). This would be a really neat tool for automated theorem proving, computer algebra systems, graph analysis, or querying databases. I'd love to explore using [E-graphs](https://egraphs-good.github.io) to perform efficient, incremental reasoning for mechanized proofs.
4. A [SAT solver](https://en.wikipedia.org/wiki/Boolean_satisfiability_problem) or [SMT solver](https://en.wikipedia.org/wiki/Satisfiability_Modulo_Theories). These are really interesting tools for solving complex logical problems and are used in a lot of places in computer science.

### Other Ideas🤔

1. Implementing an LLM with the capacity for querying a knowledge-base, plus a domain-specific-language for the LLM to use external tools (such as performing arithmetic, manipulating the filesystem, etc).
2. Logic gate / quantum circuit simulator and/or optimizer. Maybe even an HDL?
3. An SSA form optimizer for a barely-higher-level-than assembly language. It would be fun to try and implement a tiny LLVM from scratch!
